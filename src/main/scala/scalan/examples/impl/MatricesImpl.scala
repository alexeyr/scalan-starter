package scalan.examples

import scalan._
import scalan.common.OverloadHack.{Overloaded2, Overloaded1}
import scala.annotation.unchecked.uncheckedVariance
import scala.reflect.runtime.universe._
import scalan.common.Default
import scalan.meta.ScalanAst._

package impl {
// Abs -----------------------------------
trait MatricesAbs extends Matrices with Scalan {
  self: MatricesDsl with ScalanDsl =>

  // single proxy for each type family
  implicit def proxyMatrix[T](p: Rep[Matrix[T]]): Matrix[T] = {
    proxyOps[Matrix[T]](p)(scala.reflect.classTag[Matrix[T]])
  }

  // familyElem
  class MatrixElem[T, To <: Matrix[T]](implicit val eT: Elem[T])
    extends EntityElem[To] {
    lazy val parent: Option[Elem[_]] = None
    lazy val entityDef: STraitOrClassDef = {
      val module = getModules("Matrices")
      module.entities.find(_.name == "Matrix").get
    }
    lazy val tyArgSubst: Map[String, TypeDesc] = {
      Map("T" -> Left(eT))
    }
    override def isEntityType = true
    override lazy val tag = {
      implicit val tagT = eT.tag
      weakTypeTag[Matrix[T]].asInstanceOf[WeakTypeTag[To]]
    }
    override def convert(x: Rep[Reifiable[_]]) = {
      implicit val eTo: Elem[To] = this
      val conv = fun {x: Rep[Matrix[T]] => convertMatrix(x) }
      tryConvert(element[Matrix[T]], this, x, conv)
    }

    def convertMatrix(x : Rep[Matrix[T]]): Rep[To] = {
      assert(x.selfType1 match { case _: MatrixElem[_, _] => true; case _ => false })
      x.asRep[To]
    }
    override def getDefaultRep: Rep[To] = ???
  }

  implicit def matrixElement[T](implicit eT: Elem[T]): Elem[Matrix[T]] =
    new MatrixElem[T, Matrix[T]]

  implicit case object MatrixCompanionElem extends CompanionElem[MatrixCompanionAbs] {
    lazy val tag = weakTypeTag[MatrixCompanionAbs]
    protected def getDefaultRep = Matrix
  }

  abstract class MatrixCompanionAbs extends CompanionBase[MatrixCompanionAbs] with MatrixCompanion {
    override def toString = "Matrix"
  }
  def Matrix: Rep[MatrixCompanionAbs]
  implicit def proxyMatrixCompanion(p: Rep[MatrixCompanion]): MatrixCompanion =
    proxyOps[MatrixCompanion](p)

  // elem for concrete class
  class FlatMatrixElem[T](val iso: Iso[FlatMatrixData[T], FlatMatrix[T]])(implicit eT: Elem[T])
    extends MatrixElem[T, FlatMatrix[T]]
    with ConcreteElem[FlatMatrixData[T], FlatMatrix[T]] {
    override lazy val parent: Option[Elem[_]] = Some(matrixElement(element[T]))
    override lazy val entityDef = {
      val module = getModules("Matrices")
      module.concreteSClasses.find(_.name == "FlatMatrix").get
    }
    override lazy val tyArgSubst: Map[String, TypeDesc] = {
      Map("T" -> Left(eT))
    }

    override def convertMatrix(x: Rep[Matrix[T]]) = // Converter is not generated by meta
!!!("Cannot convert from Matrix to FlatMatrix: missing fields List(rmValues)")
    override def getDefaultRep = super[ConcreteElem].getDefaultRep
    override lazy val tag = {
      implicit val tagT = eT.tag
      weakTypeTag[FlatMatrix[T]]
    }
  }

  // state representation type
  type FlatMatrixData[T] = (Array[T], Int)

  // 3) Iso for concrete class
  class FlatMatrixIso[T](implicit eT: Elem[T])
    extends Iso[FlatMatrixData[T], FlatMatrix[T]]()(pairElement(implicitly[Elem[Array[T]]], implicitly[Elem[Int]])) {
    override def from(p: Rep[FlatMatrix[T]]) =
      (p.rmValues, p.numColumns)
    override def to(p: Rep[(Array[T], Int)]) = {
      val Pair(rmValues, numColumns) = p
      FlatMatrix(rmValues, numColumns)
    }
    lazy val defaultRepTo: Rep[FlatMatrix[T]] = FlatMatrix(element[Array[T]].defaultRepValue, 0)
    lazy val eTo = new FlatMatrixElem[T](this)
  }
  // 4) constructor and deconstructor
  abstract class FlatMatrixCompanionAbs extends CompanionBase[FlatMatrixCompanionAbs] {
    override def toString = "FlatMatrix"
    def apply[T](p: Rep[FlatMatrixData[T]])(implicit eT: Elem[T]): Rep[FlatMatrix[T]] =
      isoFlatMatrix(eT).to(p)
    def apply[T](rmValues: Rep[Array[T]], numColumns: Rep[Int])(implicit eT: Elem[T]): Rep[FlatMatrix[T]] =
      mkFlatMatrix(rmValues, numColumns)
  }
  object FlatMatrixMatcher {
    def unapply[T](p: Rep[Matrix[T]]) = unmkFlatMatrix(p)
  }
  def FlatMatrix: Rep[FlatMatrixCompanionAbs]
  implicit def proxyFlatMatrixCompanion(p: Rep[FlatMatrixCompanionAbs]): FlatMatrixCompanionAbs = {
    proxyOps[FlatMatrixCompanionAbs](p)
  }

  implicit case object FlatMatrixCompanionElem extends CompanionElem[FlatMatrixCompanionAbs] {
    lazy val tag = weakTypeTag[FlatMatrixCompanionAbs]
    protected def getDefaultRep = FlatMatrix
  }

  implicit def proxyFlatMatrix[T](p: Rep[FlatMatrix[T]]): FlatMatrix[T] =
    proxyOps[FlatMatrix[T]](p)

  implicit class ExtendedFlatMatrix[T](p: Rep[FlatMatrix[T]])(implicit eT: Elem[T]) {
    def toData: Rep[FlatMatrixData[T]] = isoFlatMatrix(eT).from(p)
  }

  // 5) implicit resolution of Iso
  implicit def isoFlatMatrix[T](implicit eT: Elem[T]): Iso[FlatMatrixData[T], FlatMatrix[T]] =
    new FlatMatrixIso[T]

  // 6) smart constructor and deconstructor
  def mkFlatMatrix[T](rmValues: Rep[Array[T]], numColumns: Rep[Int])(implicit eT: Elem[T]): Rep[FlatMatrix[T]]
  def unmkFlatMatrix[T](p: Rep[Matrix[T]]): Option[(Rep[Array[T]], Rep[Int])]

  // elem for concrete class
  class CompoundMatrixElem[T](val iso: Iso[CompoundMatrixData[T], CompoundMatrix[T]])(implicit eT: Elem[T])
    extends MatrixElem[T, CompoundMatrix[T]]
    with ConcreteElem[CompoundMatrixData[T], CompoundMatrix[T]] {
    override lazy val parent: Option[Elem[_]] = Some(matrixElement(element[T]))
    override lazy val entityDef = {
      val module = getModules("Matrices")
      module.concreteSClasses.find(_.name == "CompoundMatrix").get
    }
    override lazy val tyArgSubst: Map[String, TypeDesc] = {
      Map("T" -> Left(eT))
    }

    override def convertMatrix(x: Rep[Matrix[T]]) = CompoundMatrix(x.rows, x.numColumns)
    override def getDefaultRep = super[ConcreteElem].getDefaultRep
    override lazy val tag = {
      implicit val tagT = eT.tag
      weakTypeTag[CompoundMatrix[T]]
    }
  }

  // state representation type
  type CompoundMatrixData[T] = (Array[Vector[T]], Int)

  // 3) Iso for concrete class
  class CompoundMatrixIso[T](implicit eT: Elem[T])
    extends Iso[CompoundMatrixData[T], CompoundMatrix[T]]()(pairElement(implicitly[Elem[Array[Vector[T]]]], implicitly[Elem[Int]])) {
    override def from(p: Rep[CompoundMatrix[T]]) =
      (p.rows, p.numColumns)
    override def to(p: Rep[(Array[Vector[T]], Int)]) = {
      val Pair(rows, numColumns) = p
      CompoundMatrix(rows, numColumns)
    }
    lazy val defaultRepTo: Rep[CompoundMatrix[T]] = CompoundMatrix(element[Array[Vector[T]]].defaultRepValue, 0)
    lazy val eTo = new CompoundMatrixElem[T](this)
  }
  // 4) constructor and deconstructor
  abstract class CompoundMatrixCompanionAbs extends CompanionBase[CompoundMatrixCompanionAbs] {
    override def toString = "CompoundMatrix"
    def apply[T](p: Rep[CompoundMatrixData[T]])(implicit eT: Elem[T]): Rep[CompoundMatrix[T]] =
      isoCompoundMatrix(eT).to(p)
    def apply[T](rows: Rep[Array[Vector[T]]], numColumns: Rep[Int])(implicit eT: Elem[T]): Rep[CompoundMatrix[T]] =
      mkCompoundMatrix(rows, numColumns)
  }
  object CompoundMatrixMatcher {
    def unapply[T](p: Rep[Matrix[T]]) = unmkCompoundMatrix(p)
  }
  def CompoundMatrix: Rep[CompoundMatrixCompanionAbs]
  implicit def proxyCompoundMatrixCompanion(p: Rep[CompoundMatrixCompanionAbs]): CompoundMatrixCompanionAbs = {
    proxyOps[CompoundMatrixCompanionAbs](p)
  }

  implicit case object CompoundMatrixCompanionElem extends CompanionElem[CompoundMatrixCompanionAbs] {
    lazy val tag = weakTypeTag[CompoundMatrixCompanionAbs]
    protected def getDefaultRep = CompoundMatrix
  }

  implicit def proxyCompoundMatrix[T](p: Rep[CompoundMatrix[T]]): CompoundMatrix[T] =
    proxyOps[CompoundMatrix[T]](p)

  implicit class ExtendedCompoundMatrix[T](p: Rep[CompoundMatrix[T]])(implicit eT: Elem[T]) {
    def toData: Rep[CompoundMatrixData[T]] = isoCompoundMatrix(eT).from(p)
  }

  // 5) implicit resolution of Iso
  implicit def isoCompoundMatrix[T](implicit eT: Elem[T]): Iso[CompoundMatrixData[T], CompoundMatrix[T]] =
    new CompoundMatrixIso[T]

  // 6) smart constructor and deconstructor
  def mkCompoundMatrix[T](rows: Rep[Array[Vector[T]]], numColumns: Rep[Int])(implicit eT: Elem[T]): Rep[CompoundMatrix[T]]
  def unmkCompoundMatrix[T](p: Rep[Matrix[T]]): Option[(Rep[Array[Vector[T]]], Rep[Int])]

  // elem for concrete class
  class ConstMatrixElem[T](val iso: Iso[ConstMatrixData[T], ConstMatrix[T]])(implicit eT: Elem[T])
    extends MatrixElem[T, ConstMatrix[T]]
    with ConcreteElem[ConstMatrixData[T], ConstMatrix[T]] {
    override lazy val parent: Option[Elem[_]] = Some(matrixElement(element[T]))
    override lazy val entityDef = {
      val module = getModules("Matrices")
      module.concreteSClasses.find(_.name == "ConstMatrix").get
    }
    override lazy val tyArgSubst: Map[String, TypeDesc] = {
      Map("T" -> Left(eT))
    }

    override def convertMatrix(x: Rep[Matrix[T]]) = // Converter is not generated by meta
!!!("Cannot convert from Matrix to ConstMatrix: missing fields List(item)")
    override def getDefaultRep = super[ConcreteElem].getDefaultRep
    override lazy val tag = {
      implicit val tagT = eT.tag
      weakTypeTag[ConstMatrix[T]]
    }
  }

  // state representation type
  type ConstMatrixData[T] = (T, (Int, Int))

  // 3) Iso for concrete class
  class ConstMatrixIso[T](implicit eT: Elem[T])
    extends Iso[ConstMatrixData[T], ConstMatrix[T]]()(pairElement(implicitly[Elem[T]], pairElement(implicitly[Elem[Int]], implicitly[Elem[Int]]))) {
    override def from(p: Rep[ConstMatrix[T]]) =
      (p.item, p.numColumns, p.numRows)
    override def to(p: Rep[(T, (Int, Int))]) = {
      val Pair(item, Pair(numColumns, numRows)) = p
      ConstMatrix(item, numColumns, numRows)
    }
    lazy val defaultRepTo: Rep[ConstMatrix[T]] = ConstMatrix(element[T].defaultRepValue, 0, 0)
    lazy val eTo = new ConstMatrixElem[T](this)
  }
  // 4) constructor and deconstructor
  abstract class ConstMatrixCompanionAbs extends CompanionBase[ConstMatrixCompanionAbs] {
    override def toString = "ConstMatrix"
    def apply[T](p: Rep[ConstMatrixData[T]])(implicit eT: Elem[T]): Rep[ConstMatrix[T]] =
      isoConstMatrix(eT).to(p)
    def apply[T](item: Rep[T], numColumns: Rep[Int], numRows: Rep[Int])(implicit eT: Elem[T]): Rep[ConstMatrix[T]] =
      mkConstMatrix(item, numColumns, numRows)
  }
  object ConstMatrixMatcher {
    def unapply[T](p: Rep[Matrix[T]]) = unmkConstMatrix(p)
  }
  def ConstMatrix: Rep[ConstMatrixCompanionAbs]
  implicit def proxyConstMatrixCompanion(p: Rep[ConstMatrixCompanionAbs]): ConstMatrixCompanionAbs = {
    proxyOps[ConstMatrixCompanionAbs](p)
  }

  implicit case object ConstMatrixCompanionElem extends CompanionElem[ConstMatrixCompanionAbs] {
    lazy val tag = weakTypeTag[ConstMatrixCompanionAbs]
    protected def getDefaultRep = ConstMatrix
  }

  implicit def proxyConstMatrix[T](p: Rep[ConstMatrix[T]]): ConstMatrix[T] =
    proxyOps[ConstMatrix[T]](p)

  implicit class ExtendedConstMatrix[T](p: Rep[ConstMatrix[T]])(implicit eT: Elem[T]) {
    def toData: Rep[ConstMatrixData[T]] = isoConstMatrix(eT).from(p)
  }

  // 5) implicit resolution of Iso
  implicit def isoConstMatrix[T](implicit eT: Elem[T]): Iso[ConstMatrixData[T], ConstMatrix[T]] =
    new ConstMatrixIso[T]

  // 6) smart constructor and deconstructor
  def mkConstMatrix[T](item: Rep[T], numColumns: Rep[Int], numRows: Rep[Int])(implicit eT: Elem[T]): Rep[ConstMatrix[T]]
  def unmkConstMatrix[T](p: Rep[Matrix[T]]): Option[(Rep[T], Rep[Int], Rep[Int])]

  registerModule(scalan.meta.ScalanCodegen.loadModule(Matrices_Module.dump))
}

// Seq -----------------------------------
trait MatricesSeq extends MatricesDsl with ScalanSeq {
  self: MatricesDsl with ScalanCtxSeq =>
  lazy val Matrix: Rep[MatrixCompanionAbs] = new MatrixCompanionAbs with UserTypeSeq[MatrixCompanionAbs] {
    lazy val selfType = element[MatrixCompanionAbs]
  }

  case class SeqFlatMatrix[T]
      (override val rmValues: Rep[Array[T]], override val numColumns: Rep[Int])
      (implicit eT: Elem[T])
    extends FlatMatrix[T](rmValues, numColumns)
        with UserTypeSeq[FlatMatrix[T]] {
    lazy val selfType = element[FlatMatrix[T]]
  }
  lazy val FlatMatrix = new FlatMatrixCompanionAbs with UserTypeSeq[FlatMatrixCompanionAbs] {
    lazy val selfType = element[FlatMatrixCompanionAbs]
  }

  def mkFlatMatrix[T]
      (rmValues: Rep[Array[T]], numColumns: Rep[Int])(implicit eT: Elem[T]): Rep[FlatMatrix[T]] =
      new SeqFlatMatrix[T](rmValues, numColumns)
  def unmkFlatMatrix[T](p: Rep[Matrix[T]]) = p match {
    case p: FlatMatrix[T] @unchecked =>
      Some((p.rmValues, p.numColumns))
    case _ => None
  }

  case class SeqCompoundMatrix[T]
      (override val rows: Rep[Array[Vector[T]]], override val numColumns: Rep[Int])
      (implicit eT: Elem[T])
    extends CompoundMatrix[T](rows, numColumns)
        with UserTypeSeq[CompoundMatrix[T]] {
    lazy val selfType = element[CompoundMatrix[T]]
  }
  lazy val CompoundMatrix = new CompoundMatrixCompanionAbs with UserTypeSeq[CompoundMatrixCompanionAbs] {
    lazy val selfType = element[CompoundMatrixCompanionAbs]
  }

  def mkCompoundMatrix[T]
      (rows: Rep[Array[Vector[T]]], numColumns: Rep[Int])(implicit eT: Elem[T]): Rep[CompoundMatrix[T]] =
      new SeqCompoundMatrix[T](rows, numColumns)
  def unmkCompoundMatrix[T](p: Rep[Matrix[T]]) = p match {
    case p: CompoundMatrix[T] @unchecked =>
      Some((p.rows, p.numColumns))
    case _ => None
  }

  case class SeqConstMatrix[T]
      (override val item: Rep[T], override val numColumns: Rep[Int], override val numRows: Rep[Int])
      (implicit eT: Elem[T])
    extends ConstMatrix[T](item, numColumns, numRows)
        with UserTypeSeq[ConstMatrix[T]] {
    lazy val selfType = element[ConstMatrix[T]]
  }
  lazy val ConstMatrix = new ConstMatrixCompanionAbs with UserTypeSeq[ConstMatrixCompanionAbs] {
    lazy val selfType = element[ConstMatrixCompanionAbs]
  }

  def mkConstMatrix[T]
      (item: Rep[T], numColumns: Rep[Int], numRows: Rep[Int])(implicit eT: Elem[T]): Rep[ConstMatrix[T]] =
      new SeqConstMatrix[T](item, numColumns, numRows)
  def unmkConstMatrix[T](p: Rep[Matrix[T]]) = p match {
    case p: ConstMatrix[T] @unchecked =>
      Some((p.item, p.numColumns, p.numRows))
    case _ => None
  }
}

// Exp -----------------------------------
trait MatricesExp extends MatricesDsl with ScalanExp {
  self: MatricesDsl with ScalanCtxExp =>
  lazy val Matrix: Rep[MatrixCompanionAbs] = new MatrixCompanionAbs with UserTypeDef[MatrixCompanionAbs] {
    lazy val selfType = element[MatrixCompanionAbs]
    override def mirror(t: Transformer) = this
  }

  case class ExpFlatMatrix[T]
      (override val rmValues: Rep[Array[T]], override val numColumns: Rep[Int])
      (implicit eT: Elem[T])
    extends FlatMatrix[T](rmValues, numColumns) with UserTypeDef[FlatMatrix[T]] {
    lazy val selfType = element[FlatMatrix[T]]
    override def mirror(t: Transformer) = ExpFlatMatrix[T](t(rmValues), t(numColumns))
  }

  lazy val FlatMatrix: Rep[FlatMatrixCompanionAbs] = new FlatMatrixCompanionAbs with UserTypeDef[FlatMatrixCompanionAbs] {
    lazy val selfType = element[FlatMatrixCompanionAbs]
    override def mirror(t: Transformer) = this
  }

  object FlatMatrixMethods {
    object items {
      def unapply(d: Def[_]): Option[Rep[FlatMatrix[T]] forSome {type T}] = d match {
        case MethodCall(receiver, method, _, _) if receiver.elem.isInstanceOf[FlatMatrixElem[_]] && method.getName == "items" =>
          Some(receiver).asInstanceOf[Option[Rep[FlatMatrix[T]] forSome {type T}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[Rep[FlatMatrix[T]] forSome {type T}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object numRows {
      def unapply(d: Def[_]): Option[Rep[FlatMatrix[T]] forSome {type T}] = d match {
        case MethodCall(receiver, method, _, _) if receiver.elem.isInstanceOf[FlatMatrixElem[_]] && method.getName == "numRows" =>
          Some(receiver).asInstanceOf[Option[Rep[FlatMatrix[T]] forSome {type T}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[Rep[FlatMatrix[T]] forSome {type T}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object columns {
      def unapply(d: Def[_]): Option[Rep[FlatMatrix[T]] forSome {type T}] = d match {
        case MethodCall(receiver, method, _, _) if receiver.elem.isInstanceOf[FlatMatrixElem[_]] && method.getName == "columns" =>
          Some(receiver).asInstanceOf[Option[Rep[FlatMatrix[T]] forSome {type T}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[Rep[FlatMatrix[T]] forSome {type T}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object rows {
      def unapply(d: Def[_]): Option[Rep[FlatMatrix[T]] forSome {type T}] = d match {
        case MethodCall(receiver, method, _, _) if receiver.elem.isInstanceOf[FlatMatrixElem[_]] && method.getName == "rows" =>
          Some(receiver).asInstanceOf[Option[Rep[FlatMatrix[T]] forSome {type T}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[Rep[FlatMatrix[T]] forSome {type T}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }
  }

  def mkFlatMatrix[T]
    (rmValues: Rep[Array[T]], numColumns: Rep[Int])(implicit eT: Elem[T]): Rep[FlatMatrix[T]] =
    new ExpFlatMatrix[T](rmValues, numColumns)
  def unmkFlatMatrix[T](p: Rep[Matrix[T]]) = p.elem.asInstanceOf[Elem[_]] match {
    case _: FlatMatrixElem[T] @unchecked =>
      Some((p.asRep[FlatMatrix[T]].rmValues, p.asRep[FlatMatrix[T]].numColumns))
    case _ =>
      None
  }

  case class ExpCompoundMatrix[T]
      (override val rows: Rep[Array[Vector[T]]], override val numColumns: Rep[Int])
      (implicit eT: Elem[T])
    extends CompoundMatrix[T](rows, numColumns) with UserTypeDef[CompoundMatrix[T]] {
    lazy val selfType = element[CompoundMatrix[T]]
    override def mirror(t: Transformer) = ExpCompoundMatrix[T](t(rows), t(numColumns))
  }

  lazy val CompoundMatrix: Rep[CompoundMatrixCompanionAbs] = new CompoundMatrixCompanionAbs with UserTypeDef[CompoundMatrixCompanionAbs] {
    lazy val selfType = element[CompoundMatrixCompanionAbs]
    override def mirror(t: Transformer) = this
  }

  object CompoundMatrixMethods {
    object columns {
      def unapply(d: Def[_]): Option[Rep[CompoundMatrix[T]] forSome {type T}] = d match {
        case MethodCall(receiver, method, _, _) if receiver.elem.isInstanceOf[CompoundMatrixElem[_]] && method.getName == "columns" =>
          Some(receiver).asInstanceOf[Option[Rep[CompoundMatrix[T]] forSome {type T}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[Rep[CompoundMatrix[T]] forSome {type T}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object numRows {
      def unapply(d: Def[_]): Option[Rep[CompoundMatrix[T]] forSome {type T}] = d match {
        case MethodCall(receiver, method, _, _) if receiver.elem.isInstanceOf[CompoundMatrixElem[_]] && method.getName == "numRows" =>
          Some(receiver).asInstanceOf[Option[Rep[CompoundMatrix[T]] forSome {type T}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[Rep[CompoundMatrix[T]] forSome {type T}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }
  }

  def mkCompoundMatrix[T]
    (rows: Rep[Array[Vector[T]]], numColumns: Rep[Int])(implicit eT: Elem[T]): Rep[CompoundMatrix[T]] =
    new ExpCompoundMatrix[T](rows, numColumns)
  def unmkCompoundMatrix[T](p: Rep[Matrix[T]]) = p.elem.asInstanceOf[Elem[_]] match {
    case _: CompoundMatrixElem[T] @unchecked =>
      Some((p.asRep[CompoundMatrix[T]].rows, p.asRep[CompoundMatrix[T]].numColumns))
    case _ =>
      None
  }

  case class ExpConstMatrix[T]
      (override val item: Rep[T], override val numColumns: Rep[Int], override val numRows: Rep[Int])
      (implicit eT: Elem[T])
    extends ConstMatrix[T](item, numColumns, numRows) with UserTypeDef[ConstMatrix[T]] {
    lazy val selfType = element[ConstMatrix[T]]
    override def mirror(t: Transformer) = ExpConstMatrix[T](t(item), t(numColumns), t(numRows))
  }

  lazy val ConstMatrix: Rep[ConstMatrixCompanionAbs] = new ConstMatrixCompanionAbs with UserTypeDef[ConstMatrixCompanionAbs] {
    lazy val selfType = element[ConstMatrixCompanionAbs]
    override def mirror(t: Transformer) = this
  }

  object ConstMatrixMethods {
    object items {
      def unapply(d: Def[_]): Option[Rep[ConstMatrix[T]] forSome {type T}] = d match {
        case MethodCall(receiver, method, _, _) if receiver.elem.isInstanceOf[ConstMatrixElem[_]] && method.getName == "items" =>
          Some(receiver).asInstanceOf[Option[Rep[ConstMatrix[T]] forSome {type T}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[Rep[ConstMatrix[T]] forSome {type T}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object columns {
      def unapply(d: Def[_]): Option[Rep[ConstMatrix[T]] forSome {type T}] = d match {
        case MethodCall(receiver, method, _, _) if receiver.elem.isInstanceOf[ConstMatrixElem[_]] && method.getName == "columns" =>
          Some(receiver).asInstanceOf[Option[Rep[ConstMatrix[T]] forSome {type T}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[Rep[ConstMatrix[T]] forSome {type T}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object rows {
      def unapply(d: Def[_]): Option[Rep[ConstMatrix[T]] forSome {type T}] = d match {
        case MethodCall(receiver, method, _, _) if receiver.elem.isInstanceOf[ConstMatrixElem[_]] && method.getName == "rows" =>
          Some(receiver).asInstanceOf[Option[Rep[ConstMatrix[T]] forSome {type T}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[Rep[ConstMatrix[T]] forSome {type T}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }
  }

  def mkConstMatrix[T]
    (item: Rep[T], numColumns: Rep[Int], numRows: Rep[Int])(implicit eT: Elem[T]): Rep[ConstMatrix[T]] =
    new ExpConstMatrix[T](item, numColumns, numRows)
  def unmkConstMatrix[T](p: Rep[Matrix[T]]) = p.elem.asInstanceOf[Elem[_]] match {
    case _: ConstMatrixElem[T] @unchecked =>
      Some((p.asRep[ConstMatrix[T]].item, p.asRep[ConstMatrix[T]].numColumns, p.asRep[ConstMatrix[T]].numRows))
    case _ =>
      None
  }

  object MatrixMethods {
    object numColumns {
      def unapply(d: Def[_]): Option[Rep[Matrix[T]] forSome {type T}] = d match {
        case MethodCall(receiver, method, _, _) if receiver.elem.isInstanceOf[MatrixElem[_, _]] && method.getName == "numColumns" =>
          Some(receiver).asInstanceOf[Option[Rep[Matrix[T]] forSome {type T}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[Rep[Matrix[T]] forSome {type T}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object numRows {
      def unapply(d: Def[_]): Option[Rep[Matrix[T]] forSome {type T}] = d match {
        case MethodCall(receiver, method, _, _) if receiver.elem.isInstanceOf[MatrixElem[_, _]] && method.getName == "numRows" =>
          Some(receiver).asInstanceOf[Option[Rep[Matrix[T]] forSome {type T}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[Rep[Matrix[T]] forSome {type T}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object rows {
      def unapply(d: Def[_]): Option[Rep[Matrix[T]] forSome {type T}] = d match {
        case MethodCall(receiver, method, _, _) if receiver.elem.isInstanceOf[MatrixElem[_, _]] && method.getName == "rows" =>
          Some(receiver).asInstanceOf[Option[Rep[Matrix[T]] forSome {type T}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[Rep[Matrix[T]] forSome {type T}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object columns {
      def unapply(d: Def[_]): Option[Rep[Matrix[T]] forSome {type T}] = d match {
        case MethodCall(receiver, method, _, _) if receiver.elem.isInstanceOf[MatrixElem[_, _]] && method.getName == "columns" =>
          Some(receiver).asInstanceOf[Option[Rep[Matrix[T]] forSome {type T}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[Rep[Matrix[T]] forSome {type T}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }
  }

  object MatrixCompanionMethods {
  }
}

object Matrices_Module {
  val packageName = "scalan.examples"
  val name = "Matrices"
  val dump = "H4sIAAAAAAAAAM1WTYgcRRR+3Tuz87fsxqAhAYPrOiqKmVkEyWEPYTOZSGT2h+01yBiEmp6aScfq6t6qmrXHQw4eFRTEiweR3HPzIgi5iCAePIkKnj3FBAlqToqvqrvnZ3cmu1kw2Ieiu/rV+/m+r+rVzTuQlQKeky5hhFd8qkjFMe+rUpWdOlee6q8F7R6jF2jnvRNfumv8vLRhoQmzV4m8IFkTCvFLPQoH7w7daUCBcJdKFQip4OmGiVB1A8aoq7yAVz3f7ynSYrTa8KRaaUCmFbT7O3AdrAYccwPuCqqoU2NESiqT+TzVGXmD74L57m+Ewxi8qquojlSxLYinMH2McSy236Kh0+cB7/sK5pPUNkKdFtrkPD8MhEpD5NDd1aCdfmY4wQk43rhGdkkVQ3SrjhIe7+LKUkjct0mXrqOJNs9gwpKyznY/NN8zDShKuoMAXfJDZmaiEACQgZdNEpUhPpUBPhWNT9mhwiPMe5fon5siiPoQP9YMQBSii5cOcJF6oHXeLr9/xX3zvlPybb040qnkTIWz6OipKWowVCCO3259LO+9euOsDcUmFD252pJKEFeNUp6gVSKcB8rkPACQiC6ytTSNLRNlFW32SKLgBn5IOHpKoJxDnpjnekob67m5hJ0p0OdUSFNTKwqtQb2LU+o1uqkRxjZvnzrz7G/1N2ywx0MU0KWDwhepUwWzawTlECXO9bigwNo2COuhEA3H3AOCD2B4/vbd9jfLcMUegJfEOhxf6CIrf/6x9MML52zIN426LzLSbSJ+ss6ovyFqAVdNyAe7VMR/cruE6beJ/OXatEN6TCWojsIxg3AoWJy6D0OqsVoxmrdSAEqxbNcDTssXN8t/Od99clOrUsBc/CfemP94Z//+Zb6jjGAV5IV/mbAelSnEM7inx0HPrgpB+gcSYX6dHGSkh9MKirzn1wLW8/mkCAKemaaZkG4Kz8czape+8vVXr/9+az1rZHM8gc1kHZ8YCWpDBHVh1jJGusTVPq2YxEz8J0ZqOmntSdym22nCGU3vgfVjrci1imU7DKKLPD29SJTVia3G4+zOuVs2ZF+DbAf1IhuQbQU93k53KJ7iikbqfDpnjesFdyQRxE8FHZ9ni2CSMHnuSdgYlqzxkh5uw+3Dby/xGRG885Cimr2M521y5h2UwZH0poczj1AQ8zU8ajVn+0Whx5X/B1GeSoqZSNT+fI6M+eTVOVy9NVErj5quEh7gcsIGPhxXIzU+qJmkl6g/m8v2H6d++tyGAvaMlqd8EpaXD9n6/8N2DuNAFbao1/H03efoIhwhTjeqYtyOnMCnjy3d89668YEyPdmKxq+DG61reB6smMVPmhAfwtDRkGs87BfibGqjUMQkDW8SR2VUjx8NbRLDvHGqmYKFhGkaEUQ+6aSfYqFLUyTgJASgCq7f/2z9xe+/+NW0tqKmEts3H9yZR1vaONSlND5egocbXRMWB0qnU21nNOumin8BKvwvzqsMAAA="
}
}

